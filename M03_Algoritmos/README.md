# ⚙️ M03: Algoritmos Clásicos y Patrones

Este módulo se centra en los algoritmos más comunes en las entrevistas y en los patrones de resolución de problemas que te permiten transformar soluciones ingenuas en soluciones óptimas.

## 📄 Contenido del Módulo

| Archivo | Idioma | Descripción |
| :--- | :--- | :--- |
| [`M03_Algoritmos.md`](M03_Algoritmos.md) | Documentación | **Documento Principal:** Introduce los principales patrones algorítmicos (Divide y Vencerás, Greedy, Programación Dinámica, Backtracking) y cómo reconocerlos. |
| [`Practica_BusquedaBinaria.js`](Practica_BusquedaBinaria.js) | JavaScript | Implementación del algoritmo de **Búsqueda Binaria** ($O(\log n)$) en arreglos ordenados. Incluye variantes para encontrar límites superiores/inferiores. |
| [`Practica_MergeSort.py`](Practica_MergeSort.py) | Python | Implementación detallada de un algoritmo de **Ordenamiento (Merge Sort)** ($O(n \log n)$), clave para entender la filosofía de *Divide y Vencerás*. |
| [`Practica_Greedy.py`](Practica_Greedy.py) | Python | Ejemplo de un **Algoritmo Voraz (Greedy)**, donde se toma la mejor decisión local con la esperanza de obtener el mejor resultado global. |
| [`Practica_DP_Fibonacci.java`](Practica_DP_Fibonacci.java) | Java | Ejemplo de **Programación Dinámica (DP)**, mostrando la optimización de un problema recursivo mediante memorización (*memoization*). |

## 🎯 Objetivos de Aprendizaje

Al completar este módulo, serás capaz de:

1.  **Reconocer Patrones:** Identificar qué patrón algorítmico (Greedy, DP, etc.) es adecuado para un problema.
2.  **Optimización por Ordenamiento:** Aplicar Merge Sort para resolver problemas que requieren ordenar datos con eficiencia $O(n \log n)$.
3.  **Reducir la Búsqueda:** Utilizar Búsqueda Binaria para reducir la complejidad de búsqueda de $O(n)$ a $O(\log n)$.
4.  **Resolver Recursión:** Aplicar memorización o tabulación para resolver problemas de Programación Dinámica y evitar el tiempo exponencial.