# 🧱 M02: Estructuras de Datos

Este módulo es fundamental. Se centra en aprender a elegir la estructura de datos más eficiente (en términos de tiempo y espacio) para un problema dado, y en comprender su implementación subyacente.

## 📄 Contenido del Módulo

| Archivo | Idioma | Descripción |
| :--- | :--- | :--- |
| [`M02_Estructuras.md`](M02_Estructuras.md) | Documentación | **Documento Principal:** Cuándo usar cada estructura, análisis de su complejidad interna ($O(1)$ vs. $O(n)$) y la relación velocidad/memoria. |
| [`Practica_Arrays.js`](Practica_Arrays.js) | JavaScript | Implementación y manipulación de Arrays y Cadenas (Strings). Ejercicios de punteros dobles. |
| [`Practica_StackQueue.py`](Practica_StackQueue.py) | Python | Implementación de Pilas (LIFO) y Colas (FIFO) usando Listas Enlazadas o Arrays de Python. |
| [`Practica_LinkedList.java`](Practica_LinkedList.java) | Java | Implementación de Nodos y Listas Enlazadas Simples o Dobles. Enfoque en inserción y reversión. |
| [`Practica_HashTable.cpp`](Practica_HashTable.cpp) | C++ | Implementación de Tablas Hash (Mapas/Diccionarios) y ejercicios de conteo de frecuencias. |

## 🎯 Objetivos de Aprendizaje

Al completar este módulo, serás capaz de:

1.  **Selección Óptima:** Elegir la estructura de datos que minimice la complejidad temporal para una operación específica (ej. elegir un Hash Map para búsquedas $O(1)$).
2.  **Implementación Interna:** Entender cómo se implementan internamente las estructuras (ej. el concepto de nodo y puntero en Listas Enlazadas).
3.  **Manejo de Memoria:** Comprender las compensaciones entre la velocidad y el uso de memoria (ej. el costo espacial $O(n)$ de una Tabla Hash).